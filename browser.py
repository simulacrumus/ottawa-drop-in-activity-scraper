# =============================================================================
#  Project:   City of Ottawa Drop-in Activity Scraper
#  File:      browser.py
#  Author:    Emrah Kinay
#  Created:   2025-09-12
#  License:   MIT
#
#  Description:
#      Browser class with configurations to avoid bot detector. Mostly
#      generated by Claude AI
# =============================================================================

import asyncio
import random
from typing import Optional, List
from dataclasses import dataclass
from datetime import datetime
import logging
from playwright.async_api import async_playwright, Browser, BrowserContext, Page, PlaywrightContextManager

@dataclass
class BrowserConfig:
    headless: bool = True
    timeout: int = 30000  # 30 seconds in milliseconds
    max_retries: int = 3
    retry_delay: float = 1.0
    session_lifetime: int = 3600  # 1 hour
    rate_limit_delay: tuple = (1, 2)  # Random delay between requests
    
    # Browser configuration
    browser_type: str = "chromium"  # chromium, firefox, webkit
    viewport_sizes: List[tuple] = None
    user_data_dir: Optional[str] = None
    proxy: Optional[str] = None
    locale: str = "en-CA"
    timezone: str = "America/New_York"
    
    # Anti-detection settings
    disable_blink_features: List[str] = None
    extra_args: List[str] = None
    user_agents: List[str] = None
    
    # Custom headers
    default_headers = {
        "Accept-Language": "en-CA,en-US;q=0.9,en;q=0.8,fr-CA;q=0.7,fr;q=0.6",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "Accept-Encoding": "gzip, deflate, br",
        "Cache-Control": "max-age=0",
        "Upgrade-Insecure-Requests": "1",
        "Sec-Fetch-Dest": "document",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-Site": "none",
        "Sec-Fetch-User": "?1",
    }
    
    def __post_init__(self):
        if self.viewport_sizes is None:
            self.viewport_sizes = [
                (1920, 1080),
                (1366, 768),
                (1440, 900),
                (1536, 864),
                (1280, 720),
                (1600, 900),
                (1024, 768)
            ]
        
        if self.user_agents is None:
            self.user_agents = [
                # Chrome Windows
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
                
                # Chrome macOS
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
                
                # Safari macOS
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15",
                
                # Firefox
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0",
                
                # Edge
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0",
            ]
        
        if self.disable_blink_features is None:
            self.disable_blink_features = [
                "AutomationControlled"
            ]
        
        if self.extra_args is None:
            self.extra_args = [
                 "--disable-blink-features=AutomationControlled",
                "--exclude-switches=enable-automation",
                "--disable-extensions-except=/path/to/extension",
                "--disable-plugins-discovery",
                "--disable-default-apps",
                "--disable-background-timer-throttling",
                "--disable-backgrounding-occluded-windows",
                "--disable-renderer-backgrounding",
                "--disable-features=TranslateUI,BlinkGenPropertyTrees",
                "--disable-ipc-flooding-protection",
                "--disable-field-trial-config",
                "--disable-back-forward-cache",
                "--disable-hang-monitor",
                "--disable-prompt-on-repost",
                "--disable-sync",
                "--metrics-recording-only",
                "--no-report-upload",
                "--mute-audio",
                "--no-default-browser-check",
                "--no-first-run",
                "--disable-dev-shm-usage",
                "--disable-gpu",
                "--no-sandbox",
                "--disable-web-security",
                "--allow-running-insecure-content",
                "--ignore-certificate-errors",
                "--ignore-ssl-errors",
                "--ignore-certificate-errors-spki-list",
                "--disable-features=VizDisplayCompositor",
                "--user-agent-product=Chrome",
                "--disable-logging",
                "--silent",
                "--disable-gpu-sandbox",
                "--window-position=0,0",
            ]

class BrowserManager:
    def __init__(self, config: BrowserConfig = BrowserConfig()):
        self.config = config
        self.playwright: Optional[PlaywrightContextManager] = None
        self.browser: Optional[Browser] = None
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.session_created_at: Optional[datetime] = None
        self.request_count: int = 0
        self.last_request_time: Optional[datetime] = None
        self.current_user_agent: str = ""
        self.logger = logging.getLogger(__name__)
    
    async def __aenter__(self):
        await self.initialize()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.cleanup()
    
    async def initialize(self):
        if self.playwright is None:
            await self._create_new_session()
    
    async def cleanup(self):
        try:
            if self.page:
                await self.page.close()
            if self.context:
                await self.context.close()
            if self.browser:
                await self.browser.close()
            if self.playwright:
                await self.playwright.stop()
        except Exception as e:
            self.logger.warning(f"Error during cleanup: {e}")
        finally:
            self.playwright = None
            self.browser = None
            self.context = None
            self.page = None
    
    async def _create_new_session(self):
        self.playwright = await async_playwright().start()
        
        # Select random viewport
        viewport = random.choice(self.config.viewport_sizes)
        
        # Select random user agent
        self.current_user_agent = random.choice(self.config.user_agents)
        
        # Get browser engine
        browser_engine = getattr(self.playwright, self.config.browser_type)

        # Launch browser with configuration
        launch_options = {
            "headless": self.config.headless,
            "args": self.config.extra_args
        }
        
        # Add proxy if configured
        if self.config.proxy:
            launch_options["proxy"] = {"server": self.config.proxy}
        
        self.browser = await browser_engine.launch(**launch_options)

        context_options = {
            "viewport": {"width": viewport[0], "height": viewport[1]},
            "user_agent": self.current_user_agent,
            "locale": self.config.locale,
            "timezone_id": self.config.timezone,
            "permissions": ["geolocation"],  # Grant some permissions
            "extra_http_headers": self.config.default_headers,
            "device_scale_factor": random.choice([1.0, 1.25, 1.5, 2.0]),
            "is_mobile": False,
            "has_touch": random.choice([True, False]),
            "color_scheme": random.choice(["light", "dark"]),
            "reduced_motion": random.choice(["reduce", "no-preference"]),
            "forced_colors": "none",
            # Geolocation for Ottawa, Canada
            "geolocation": {"latitude": 45.4215 + random.uniform(-0.1, 0.1), 
                          "longitude": -75.2972 + random.uniform(-0.1, 0.1), 
                          "accuracy": random.randint(10, 100)},
        }
        
        # Add user data directory if specified (persistent context)
        if self.config.user_data_dir:
            # Close browser and create persistent context
            await self.browser.close()
            self.browser = await browser_engine.launch_persistent_context(
                user_data_dir=self.config.user_data_dir,
                headless=self.config.headless,
                args=self.config.extra_args,
                **context_options
            )
            self.context = self.browser
        else:
            self.context = await self.browser.new_context(**context_options)
        
        # Create page
        self.page = await self.context.new_page()
        
        # Set default timeout
        self.page.set_default_timeout(self.config.timeout)
        
        # Add anti-detection scripts
        await self._inject_anti_detection_scripts()
        
        # Set up request/response interceptors
        await self._setup_interceptors()
        
        self.session_created_at = datetime.now()
        self.request_count = 0
        
        self.logger.info(f"New {self.config.browser_type} session created with viewport: {viewport}")
        self.logger.debug(f"User agent: {self.current_user_agent[:50]}...")
    
    async def _inject_anti_detection_scripts(self):
        await self.page.add_init_script("""
            // Remove webdriver property
            Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined,
            });
            
            // Mock plugins
            Object.defineProperty(navigator, 'plugins', {
                get: () => [1, 2, 3, 4, 5],
            });
            
            // Mock languages based on locale
            Object.defineProperty(navigator, 'languages', {
                get: () => ['en-US', 'en'],
            });
            
            // Override permissions
            const originalQuery = window.navigator.permissions.query;
            window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                    Promise.resolve({ state: Notification.permission }) :
                    originalQuery(parameters)
            );
            
            // Mock chrome object for Chromium-based browsers
            if (!window.chrome) {
                window.chrome = {
                    runtime: {},
                    loadTimes: function() {
                        return {
                            requestTime: Date.now() / 1000,
                            startLoadTime: Date.now() / 1000,
                            commitLoadTime: Date.now() / 1000,
                            finishDocumentLoadTime: Date.now() / 1000,
                            finishLoadTime: Date.now() / 1000,
                            firstPaintTime: Date.now() / 1000,
                            firstPaintAfterLoadTime: 0,
                            navigationType: 'Other',
                            wasFetchedViaSpdy: false,
                            wasNpnNegotiated: false,
                            npnNegotiatedProtocol: 'unknown',
                            wasAlternateProtocolAvailable: false,
                            connectionInfo: 'http/1.1'
                        };
                    },
                    csi: function() {
                        return {
                            startE: Date.now(),
                            onloadT: Date.now(),
                            pageT: Date.now(),
                            tran: 15
                        };
                    }
                };
            }
            
            // Mock webkit properties
            Object.defineProperty(navigator, 'webkitTemporaryStorage', {
                get: () => ({
                    queryUsageAndQuota: () => Promise.resolve({})
                })
            });
        """)
    
    async def _setup_interceptors(self):
        async def handle_route(route):
            # Add random delays to requests
            await asyncio.sleep(random.uniform(0.1, 0.5))
            await route.continue_()
        
        await self.page.route("**/*", handle_route)
    
    async def _ensure_session(self):
        if self.page is None:
            await self._create_new_session()
    
    async def _apply_rate_limit(self):
        if self.last_request_time:
            delay = random.uniform(*self.config.rate_limit_delay)
            await asyncio.sleep(delay)
    
    async def goto(self, url: str, wait_until: str = "domcontentloaded", **kwargs):
        await self._ensure_session()
        
        # Apply rate limiting
        await self._apply_rate_limit()
        
        for attempt in range(self.config.max_retries):
            try:
                self.logger.debug(f"Navigating to: {url} (attempt {attempt + 1})")
                
                response = await self.page.goto(url, wait_until=wait_until, **kwargs)
                self.request_count += 1
                self.last_request_time = datetime.now()
                
                if response and response.status < 400:
                    return response
                elif response and response.status == 429:
                    await self._handle_rate_limit(attempt)
                    continue
                elif response and response.status in [403, 406]:
                    await self._handle_bot_detection(attempt)
                    continue
                else:
                    if attempt < self.config.max_retries - 1:
                        delay = self.config.retry_delay * (2 ** attempt)
                        self.logger.warning(f"Request failed with status {response.status if response else 'None'}, retrying in {delay}s")
                        await asyncio.sleep(delay)
                        continue
                    return response
                    
            except Exception as e:
                self.logger.error(f"Navigation failed on attempt {attempt + 1}: {e}")
                if attempt < self.config.max_retries - 1:
                    await asyncio.sleep(self.config.retry_delay * (attempt + 1))
                    continue
                raise
        
        raise Exception(f"All {self.config.max_retries} attempts failed for {url}")
    
    async def get_content(self, url: str, **kwargs) -> str:
        await self.goto(url, **kwargs)
        return await self.page.content()
    
    async def get_text(self, selector: str = None) -> str:
        await self._ensure_session()
        if selector:
            try:
                element = await self.page.wait_for_selector(selector, timeout=10000)
                return await element.text_content() if element else ""
            except:
                return ""
        return await self.page.text_content("body")
    
    async def _handle_rate_limit(self, attempt: int):
        delay = self.config.retry_delay * (2 ** attempt)
        self.logger.warning(f"Rate limited, waiting {delay}s before retry")
        await asyncio.sleep(delay)
    
    async def _handle_bot_detection(self, attempt: int):
        delay = self.config.retry_delay * (2 ** attempt)
        self.logger.warning(f"Bot detection triggered, waiting {delay}s before retry")
        await asyncio.sleep(delay)
        
        # Try to refresh the page
        try:
            await self.page.reload()
        except:
            pass
